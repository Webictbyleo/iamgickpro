<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Final Canvas Positioning Fixes Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
        }
        .test-container {
            display: flex;
            gap: 20px;
            height: calc(100vh - 100px);
        }
        .controls {
            width: 250px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            overflow-y: auto;
        }
        .canvas-container {
            flex: 1;
            border: 2px solid #333;
            background: white;
            position: relative;
            min-height: 400px;
        }
        button {
            display: block;
            width: 100%;
            margin: 8px 0;
            padding: 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background: #0056b3;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .test-section h4 {
            margin: 0 0 10px 0;
            color: #333;
        }
        .info {
            background: #e9ecef;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 12px;
        }
        #debug-info {
            margin-top: 20px;
            padding: 10px;
            background: #1e1e1e;
            color: #00ff00;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        .color-input {
            width: 100%;
            height: 40px;
            margin: 10px 0;
            border: none;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>Final Canvas Positioning Fixes Test</h1>
    <p>Testing the optimized <code>fitCanvasToViewport</code> method and layer positioning fixes:</p>
    <ul>
        <li><strong>Adaptive Padding:</strong> Better space utilization with viewport-based padding</li>
        <li><strong>Smart Scaling:</strong> Allows higher zoom for small canvases in large viewports</li>
        <li><strong>Position Preset Fix:</strong> Layers at (0,0) should appear at canvas top-left</li>
        <li><strong>LayerManager Integration:</strong> No double transformation issues</li>
    </ul>
    
    <div class="test-container">
        <div class="controls">
            <div class="test-section">
                <h4>Canvas Creation</h4>
                <button onclick="createTinyCanvas()">Tiny Canvas (100x100)</button>
                <button onclick="createSmallCanvas()">Small Canvas (400x400)</button>
                <button onclick="createMediumCanvas()">Medium Canvas (800x600)</button>
                <button onclick="createLargeCanvas()">Large Canvas (1200x1200)</button>
                <button onclick="createWideCanvas()">Wide Canvas (1600x400)</button>
            </div>
            
            <div class="test-section">
                <h4>Viewport Tests</h4>
                <button onclick="fitToViewport()">Fit to Viewport (Optimized)</button>
                <button onclick="resetZoom()">Reset Zoom (1:1)</button>
                <button onclick="centerView()">Center View</button>
            </div>
            
            <div class="test-section">
                <h4>Layer Position Tests</h4>
                <button onclick="addLayerAtOrigin()">Add Layer at (0,0)</button>
                <button onclick="addLayerAtCenter()">Add Layer at Center</button>
                <button onclick="addLayerAtCorner()">Add Layer at Bottom-Right</button>
                <button onclick="testPositionPresets()">Test Position Presets</button>
                <button onclick="clearLayers()">Clear All Layers</button>
            </div>
            
            <div class="test-section">
                <h4>Background</h4>
                <input type="color" class="color-input" value="#ffffff" onchange="setBackgroundColor(this.value)">
                <button onclick="setBackgroundColor('#f0f0f0')">Light Gray</button>
                <button onclick="setBackgroundColor('#2d3748')">Dark Gray</button>
            </div>
            
            <div class="info">
                <strong>Expected Results:</strong><br>
                ‚Ä¢ Small canvases should scale up more (6x max)<br>
                ‚Ä¢ Less padding for better space use<br>
                ‚Ä¢ Layers at (0,0) appear at canvas top-left<br>
                ‚Ä¢ No double transformation issues<br>
                ‚Ä¢ Smooth zoom/pan without positioning bugs
            </div>
        </div>
        
        <div class="canvas-container" id="canvas-container">
            <!-- Canvas will be created here -->
        </div>
    </div>
    
    <div id="debug-info">Debug output will appear here...</div>

    <script src="https://unpkg.com/konva@9/konva.min.js"></script>
    <script>
        let stage = null;
        let mainLayer = null;
        let backgroundLayer = null;
        let canvasManager = null;
        let layerManager = null;
        let layerCounter = 0;

        function log(message) {
            const debugInfo = document.getElementById('debug-info');
            const timestamp = new Date().toLocaleTimeString();
            debugInfo.textContent += `[${timestamp}] ${message}\n`;
            debugInfo.scrollTop = debugInfo.scrollHeight;
            console.log(message);
        }

        // Simplified CanvasManager implementation with optimized fitCanvasToViewport
        class TestCanvasManager {
            constructor(container, width, height) {
                this.container = container;
                this.originalWidth = width;
                this.originalHeight = height;
                this.backgroundColor = '#ffffff';
                
                // Clear container
                container.innerHTML = '';
                
                // Create Konva stage
                this.stage = new Konva.Stage({
                    container: container,
                    width: width,
                    height: height
                });
                
                // Create background layer
                this.backgroundLayer = new Konva.Layer();
                this.stage.add(this.backgroundLayer);
                
                // Create main content layer (simulating LayerManager)
                this.mainLayer = new Konva.Layer();
                this.stage.add(this.mainLayer);
                
                this.createBackground();
                log(`‚úÖ Canvas created: ${width}√ó${height}`);
            }
            
            createBackground() {
                if (this.backgroundRect) {
                    this.backgroundRect.destroy();
                }
                
                this.backgroundRect = new Konva.Rect({
                    x: 0,
                    y: 0,
                    width: this.originalWidth,
                    height: this.originalHeight,
                    fill: this.backgroundColor,
                    listening: false,
                    name: 'canvas-background'
                });
                
                this.backgroundLayer.add(this.backgroundRect);
                this.backgroundLayer.batchDraw();
            }
            
            setBackgroundColor(color) {
                this.backgroundColor = color;
                this.createBackground();
            }
            
            // OPTIMIZED fitCanvasToViewport with adaptive padding and smart scaling
            fitCanvasToViewport() {
                const containerRect = this.container.getBoundingClientRect();
                const availableWidth = containerRect.width;
                const availableHeight = containerRect.height;
                
                const canvasWidth = this.originalWidth;
                const canvasHeight = this.originalHeight;
                
                // OPTIMIZED: Use adaptive padding based on viewport size
                const minPadding = 20;
                const maxPadding = 50;
                const paddingRatio = 0.05; // 5% of viewport size
                
                const adaptivePaddingX = Math.max(minPadding, Math.min(maxPadding, availableWidth * paddingRatio));
                const adaptivePaddingY = Math.max(minPadding, Math.min(maxPadding, availableHeight * paddingRatio));
                
                const targetWidth = Math.max(availableWidth - adaptivePaddingX * 2, 200);
                const targetHeight = Math.max(availableHeight - adaptivePaddingY * 2, 150);
                
                // Calculate scale
                const scaleX = targetWidth / canvasWidth;
                const scaleY = targetHeight / canvasHeight;
                let scale = Math.min(scaleX, scaleY);
                
                // OPTIMIZED: Better scale limits based on canvas size and viewport
                const canvasArea = canvasWidth * canvasHeight;
                const viewportArea = availableWidth * availableHeight;
                const areaRatio = viewportArea / canvasArea;
                
                // For very small canvases in large viewports, allow more scaling
                const maxScale = areaRatio > 16 ? 6 : areaRatio > 4 ? 4 : 3;
                scale = Math.min(scale, maxScale);
                scale = Math.max(scale, 0.05);
                
                log(`üîç Optimized fit calculation:
  Viewport: ${availableWidth}√ó${availableHeight}
  Canvas: ${canvasWidth}√ó${canvasHeight}
  Adaptive padding: ${adaptivePaddingX.toFixed(1)}px (${(adaptivePaddingX/availableWidth*100).toFixed(1)}%)
  Area ratio: ${areaRatio.toFixed(2)} (viewport/canvas)
  Scale limits: 0.05 - ${maxScale}x
  Final scale: ${scale.toFixed(2)}x (${scale < 1 ? 'down' : scale > 1 ? 'up' : 'same'})`);
                
                // Center the canvas
                const scaledCanvasWidth = canvasWidth * scale;
                const scaledCanvasHeight = canvasHeight * scale;
                
                const x = (availableWidth - scaledCanvasWidth) / 2;
                const y = (availableHeight - scaledCanvasHeight) / 2;
                
                this.stage.scale({ x: scale, y: scale });
                this.stage.position({ x, y });
                
                log(`‚úÖ Applied fit: position(${x.toFixed(1)}, ${y.toFixed(1)}) scale(${scale.toFixed(2)})`);
            }
            
            resetZoom() {
                this.stage.scale({ x: 1, y: 1 });
                this.stage.position({ x: 0, y: 0 });
                log('‚úÖ Zoom reset to 1:1');
            }
            
            centerView() {
                const containerRect = this.container.getBoundingClientRect();
                const centerX = containerRect.width / 2;
                const centerY = containerRect.height / 2;
                
                this.stage.position({ x: centerX, y: centerY });
                log(`‚úÖ View centered at (${centerX}, ${centerY})`);
            }
            
            addTestLayer(x, y, label) {
                const rect = new Konva.Rect({
                    x: x,
                    y: y,
                    width: 80,
                    height: 60,
                    fill: `hsl(${layerCounter * 60}, 70%, 60%)`,
                    stroke: '#333',
                    strokeWidth: 2,
                    draggable: true
                });
                
                const text = new Konva.Text({
                    x: x + 5,
                    y: y + 20,
                    text: label,
                    fontSize: 12,
                    fill: '#333',
                    draggable: true
                });
                
                this.mainLayer.add(rect);
                this.mainLayer.add(text);
                this.mainLayer.batchDraw();
                
                layerCounter++;
                log(`‚úÖ Added layer "${label}" at (${x}, ${y})`);
                
                return { rect, text };
            }
            
            clearLayers() {
                this.mainLayer.destroyChildren();
                this.mainLayer.batchDraw();
                layerCounter = 0;
                log('‚úÖ Cleared all layers');
            }
            
            getCanvasSize() {
                return { width: this.originalWidth, height: this.originalHeight };
            }
        }

        // Canvas creation functions
        function createTinyCanvas() {
            canvasManager = new TestCanvasManager(
                document.getElementById('canvas-container'),
                100, 100
            );
            log('üéØ Created TINY canvas - should scale up significantly (6x max)');
        }

        function createSmallCanvas() {
            canvasManager = new TestCanvasManager(
                document.getElementById('canvas-container'),
                400, 400
            );
            log('üéØ Created SMALL canvas - should scale up moderately');
        }

        function createMediumCanvas() {
            canvasManager = new TestCanvasManager(
                document.getElementById('canvas-container'),
                800, 600
            );
            log('üéØ Created MEDIUM canvas - should fit nicely');
        }

        function createLargeCanvas() {
            canvasManager = new TestCanvasManager(
                document.getElementById('canvas-container'),
                1200, 1200
            );
            log('üéØ Created LARGE canvas - should scale down');
        }

        function createWideCanvas() {
            canvasManager = new TestCanvasManager(
                document.getElementById('canvas-container'),
                1600, 400
            );
            log('üéØ Created WIDE canvas - testing aspect ratio handling');
        }

        // Viewport control functions
        function fitToViewport() {
            if (!canvasManager) {
                alert('Create a canvas first!');
                return;
            }
            canvasManager.fitCanvasToViewport();
        }

        function resetZoom() {
            if (!canvasManager) {
                alert('Create a canvas first!');
                return;
            }
            canvasManager.resetZoom();
        }

        function centerView() {
            if (!canvasManager) {
                alert('Create a canvas first!');
                return;
            }
            canvasManager.centerView();
        }

        // Layer testing functions
        function addLayerAtOrigin() {
            if (!canvasManager) {
                alert('Create a canvas first!');
                return;
            }
            canvasManager.addTestLayer(0, 0, 'Origin (0,0)');
            log('üéØ CRITICAL TEST: Layer at (0,0) should appear at canvas top-left corner');
        }

        function addLayerAtCenter() {
            if (!canvasManager) {
                alert('Create a canvas first!');
                return;
            }
            const { width, height } = canvasManager.getCanvasSize();
            const centerX = width / 2 - 40; // Account for layer width
            const centerY = height / 2 - 30; // Account for layer height
            canvasManager.addTestLayer(centerX, centerY, 'Center');
            log(`üéØ Added layer at canvas center (${centerX}, ${centerY})`);
        }

        function addLayerAtCorner() {
            if (!canvasManager) {
                alert('Create a canvas first!');
                return;
            }
            const { width, height } = canvasManager.getCanvasSize();
            const cornerX = width - 80; // Account for layer width
            const cornerY = height - 60; // Account for layer height
            canvasManager.addTestLayer(cornerX, cornerY, 'Corner');
            log(`üéØ Added layer at bottom-right corner (${cornerX}, ${cornerY})`);
        }

        function testPositionPresets() {
            if (!canvasManager) {
                alert('Create a canvas first!');
                return;
            }
            
            const { width, height } = canvasManager.getCanvasSize();
            
            // Test the position preset calculations directly
            const presets = [
                { name: 'top-left', x: 0, y: 0 },
                { name: 'top-center', x: (width - 80) / 2, y: 0 },
                { name: 'top-right', x: width - 80, y: 0 },
                { name: 'center', x: (width - 80) / 2, y: (height - 60) / 2 },
                { name: 'bottom-right', x: width - 80, y: height - 60 }
            ];
            
            log('üéØ TESTING POSITION PRESETS:');
            presets.forEach(preset => {
                canvasManager.addTestLayer(preset.x, preset.y, preset.name);
                log(`  - ${preset.name}: (${preset.x}, ${preset.y})`);
            });
            
            log('üéØ All presets should be positioned correctly relative to canvas edges');
        }

        function clearLayers() {
            if (!canvasManager) {
                alert('Create a canvas first!');
                return;
            }
            canvasManager.clearLayers();
        }

        function setBackgroundColor(color) {
            if (!canvasManager) {
                alert('Create a canvas first!');
                return;
            }
            canvasManager.setBackgroundColor(color);
            log(`‚úÖ Background color set to ${color}`);
        }

        // Initialize with a small canvas to demonstrate the improvements
        window.onload = function() {
            log('=== FINAL CANVAS POSITIONING FIXES TEST ===');
            log('This test validates:');
            log('1. Optimized fitCanvasToViewport with adaptive padding');
            log('2. Smart scaling limits based on canvas/viewport ratio');
            log('3. Fixed layer positioning (no double transformation)');
            log('4. LayerManager integration fixes');
            log('');
            log('Creating initial small canvas...');
            createSmallCanvas();
            
            // Demonstrate the improvements
            setTimeout(() => {
                log('');
                log('üéØ Auto-testing fit to viewport...');
                fitToViewport();
                
                setTimeout(() => {
                    log('');
                    log('üéØ Auto-testing layer at origin...');
                    addLayerAtOrigin();
                }, 1000);
            }, 500);
        };
    </script>
</body>
</html>
